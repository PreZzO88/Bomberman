<!doctype html>
<HTML>
	<HEAD>
		<TITLE>:: Bomberman</TITLE>
		<script src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
	</HEAD>
	<BODY style="background-color: #000000;">
		<div style="margin: 0px auto; text-align: center;">
			<canvas id="canvas" width="800" height="600" style="border-radius: 5px;"></canvas>
			<img id="bmcache" style="display: none;" src="imgs/bmcache.png" />
		</div>
		<script>
			//$(document).ready(function() {
				
				// Bomberman coded by David Preseault.
				// Note: Sprites and gameplay based on Jippii.fr Bomberman Game.
				
				var ctx = $("#canvas")[0].getContext("2d");
				var fpsctr = 0;
				var ts = new Date().getTime();
				var gameInfo = {
					bgcolor: "#4D7195",
					boardcolor: "#0075B9",
					board: [],
					boardwidth: 571,
					boardheight: 451,
					bmcache: $("#bmcache")[0],
					alternateAnimationSpeed: 200,
					players: { me: { cr: 1, cc: 2, x: 0, y: 0, color: "red", dir: "s", altDir: 0, isStopping: 0, isStopped: 1 } },
					entityBitmap: {},
					speed: { normal: 0.5, fast: 0.75, fastest: 1 }
				};

				prepare();

				var timer = setInterval(
					function() {
						ctx.fillStyle = gameInfo.bgcolor;
						ctx.fillRect(10,1,40,11);
						ctx.font = "10pt verdana";
						ctx.fillStyle = "#FFFFFF";
						ctx.fillText(fpsctr + " FPS", 10, 10);
						fpsctr = 0;
					}, 1000);
				
				
				function mainRender() {
					fpsctr++;
					// players
					// items
					// active bombs
					// active explosions
					
					//clearBoard();
					// If not stopped, draw.
					var y = gameInfo.players["me"].y;
					var x = gameInfo.players["me"].x;
					var w = gameInfo.players["me"].w;
					var h = gameInfo.players["me"].h;
					var dir = gameInfo.players["me"].dir;
					var currentRow = gameInfo.players["me"].cr;
					var currentCol = gameInfo.players["me"].cc;
					var isStopped = gameInfo.players["me"].isStopped;
					var isStopping = gameInfo.players["me"].isStopping;
					var collisiony;
					var speed = gameInfo.speed.fast;
					
						if (!isStopped) {
							switch (dir) {
								case "u":
									// UP
									collisiony = Math.floor(((Math.floor(y) - 23) / 30));
									lastOccupiedRowBlock = Math.floor(((y + h - 20 - speed) / 30));
									if (collisiony > 0) {
										if (gameInfo.board[collisiony][currentCol] != "e") {
											drawPlayer(gameInfo.players["me"].color, x, (currentRow * 30) + 22, dir, 0);
											gameInfo.players["me"].isStopping = 0;
											gameInfo.players["me"].isStopped = 1;
										} else {
											movePlayer(x, y, speed, dir);
										}
									} else {
										if (y <= 23) {
											drawPlayer(gameInfo.players["me"].color, x, 22, dir, 0);
											gameInfo.players["me"].isStopping = 0;
											gameInfo.players["me"].isStopped = 1;
										} else {
											movePlayer(x, y, speed, dir);
										}
									}
									break;
								case "r":
									break;
								case "d":
									// DOWN
									collisiony = Math.floor(((Math.floor(y) + h - 17) / 30));
									lastOccupiedRowBlock = Math.floor(((y - 20 - speed) / 30));
									if (collisiony < 14) {
										if (gameInfo.board[collisiony][currentCol] != "e") {
											drawPlayer(gameInfo.players["me"].color, x, (currentRow * 30) + 30 + 20 - h - 2, dir, 0);
											gameInfo.players["me"].isStopping = 0;
											gameInfo.players["me"].isStopped = 1;
										} else {
											movePlayer(x, y, speed, dir);
										}
									} else {
										if (y+h >= 469) {
											drawPlayer(gameInfo.players["me"].color, x, 469-h, dir, 0);
											gameInfo.players["me"].isStopping = 0;
											gameInfo.players["me"].isStopped = 1;
										} else {
											movePlayer(x, y, speed, dir);
										}
									}
									break;
								case "l":
									break;
							}
						
					}
					window.requestAnimationFrame(mainRender);
				}
				function movePlayer(x, y, speed, dir) {
					var elapsed = new Date().getTime() - ts;
					switch (dir) {
						case "u": y-=speed; break;
						case "d": y+=speed; break;
						case "l": x-=speed; break;
						case "r": x+=speed; break;
					}
					if (elapsed >= gameInfo.alternateAnimationSpeed) {
						ts = new Date().getTime();
						gameInfo.players["me"].altDir++;
						if (gameInfo.players["me"].altDir >= 3) { gameInfo.players["me"].altDir = 1; }
					}
					if (gameInfo.players["me"].isStopping) { gameInfo.players["me"].altDir = 0; gameInfo.players["me"].isStopping = 0; gameInfo.players["me"].isStopped = 1; }
					drawPlayer(gameInfo.players["me"].color, x, y, dir, gameInfo.players["me"].altDir);
				}
				
				
				function loadEntityBitmap() {
					gameInfo.entityBitmap["w"] = { x: 0, y: 30, w: 31, h: 31 };
					gameInfo.entityBitmap["b"] = { x: 0, y: 0, w: 31, h: 31 };
					gameInfo.entityBitmap["bomb"] = { x: 1, y: 145, w: 28, h: 30 };
					gameInfo.entityBitmap["armor"] = { x: 36, y: 203, w: 22, h: 27 };
					gameInfo.entityBitmap["speed"] = { x: 1, y: 62, w: 30, h: 22 };
					gameInfo.entityBitmap["exp"] = { x: 4, y: 85, w: 24, h: 26 };
					gameInfo.entityBitmap["abomb"] = { x: 0, y: 113, w: 30, h: 30 };
					
					var colors = [ "pink", "cyan", "red", "yellow", "blue", "lime", "gold", "green" ];
					var y = 0;
					for (color in colors) {
						gameInfo.entityBitmap[colors[color]] = {
							d0: { x: 33, y: y, w: 29, h: 23 }, d1: { x: 144, y: y, w: 29, h: 23 }, d2: { x: 255, y: y, w: 29, h: 23 },
							u0: { x: 87, y: y, w: 29, h: 23 }, u1: { x: 198, y: y, w: 29, h: 22 }, u2: { x: 309, y: y, w: 29, h: 22 },
							r0: { x: 120, y: y, w: 20, h: 23 }, r1: { x: 231, y: y, w: 20, h: 23 }, r2: { x: 342, y: y, w: 20, h: 23 },
							l0: { x: 65, y: y, w: 20, h: 23 }, l1: { x: 176, y: y, w: 20, h: 23}, l2: { x: 287, y: y, w: 20, h: 23 }
						};
						y+= 25;
					}
				}
				function drawItem(item, x, y) {
					ctx.drawImage(bmcache, gameInfo.entityBitmap[item].x, gameInfo.entityBitmap[item].y, gameInfo.entityBitmap[item].w, gameInfo.entityBitmap[item].h, x, y, gameInfo.entityBitmap[item].w, gameInfo.entityBitmap[item].h);
				}
				function drawPlayer(item, x, y, direction, alt) {
					var w = gameInfo.entityBitmap[item][direction + alt].w;
					var h = gameInfo.entityBitmap[item][direction + alt].h;

					gameInfo.players["me"].x = x;
					gameInfo.players["me"].y = y;
					gameInfo.players["me"].w = w;
					gameInfo.players["me"].h = h;
					var currentRowTopBody = Math.floor((y - 20) / 30);
					var currentColLeftBody = Math.floor((x - 20) / 30);
					var currentRowBottomBody = Math.floor((y + h - 18) / 30);
					var currentColRightBody = Math.floor((x + w - 18) / 30);
					// If going up or down, clear any blocks player might be in (max 2)
					// x y coordinates of players are top left of sprite. legs or right side might be in diff. blocks.
					if (direction == "u" || direction == "d") {
						if (currentRowTopBody == currentRowBottomBody) {
							console.log("cb1");
							clearBlock(currentRowTopBody, currentColLeftBody);
						} else {
						console.log("cb2");
							clearBlock(currentRowTopBody, currentColLeftBody);
							clearBlock(currentRowBottomBody, currentColLeftBody);
						}
					} else {
						if (currentColLeftBody == currentColRightBody) {
						console.log("cb3");
							clearBlock(currentRowTopBody, currentColLeftBody);
						} else {
						console.log("cb4");
							clearBlock(currentRowTopBody, currentColLeftBody);
							clearBlock(currentRowTopBody, currentColRightBody);
						}
					}
					gameInfo.players["me"].cr = currentRowTopBody;
					gameInfo.players["me"].cc = currentColLeftBody;
					ctx.drawImage(bmcache, gameInfo.entityBitmap[item][direction + alt].x, gameInfo.entityBitmap[item][direction + alt].y, w, h, x, y, w, h);
				}
				function clearBlock(r,c) {
					console.log("r: " + r + " c: " + c);
					var y = 20;
					var x = 20;
					var w = 31;
					var h = 31;
					ctx.fillStyle = gameInfo.boardcolor;
					// If block on top is not empty
					if (r > 0) {
						if (gameInfo.board[r - 1][c] != "e") { y = 21; }
					}
					// If block below is not empty (check if border-block)
					if (r < 14) {
						if (gameInfo.board[r + 1][c] != "e") { h = (y == 20 ? 30 : 29); }
					} else {
						h = (y == 20 ? 31 : 30);
					}
					// If block to the left is not empty
					if (c > 0) {
						if (gameInfo.board[r][c - 1] != "e") { x = 21; }
					}
					// If block to the right is not empty (check if border-block)
					if (c < 18) {
						if (gameInfo.board[r][c + 1] != "e") { w = (x == 20 ? 30 : 29); }
					} else {
						w = (x == 20 ? 31 : 30);
					}
					ctx.fillRect(x + (c * 30),y + (r * 30),w,h);
					gameInfo.board[r][c] = "e";
				}
				function loadBoardTiles() {
					gameInfo.board[0] = "eebbbbbbeeebbbbbbee";
					gameInfo.board[1] = "ewbwbwbwbwbwbwbwbwe";
					gameInfo.board[2] = "bbbbbbbbbbbbbbbbbbb";
					gameInfo.board[3] = "bwbwbwbwbwbwbwbwbwb";
					gameInfo.board[4] = "bbbbbbbbbbbbbbbbbbb";
					gameInfo.board[5] = "bwbwbwbwbwbwbwbwbwb";
					gameInfo.board[6] = "ebbbbbbbbbbbbbbbbbe";
					gameInfo.board[7] = "ewbwbwbwbwbwbwbwbwe";
					gameInfo.board[8] = "ebbbbbbbbbbbbbbbbbe";
					gameInfo.board[9] = "bwbwbwbwbwbwbwbwbwb";
					gameInfo.board[10] = "bbbbbbbbbbbbbbbbbbb";
					gameInfo.board[11] = "bwbwbwbwbwbwbwbwbwb";
					gameInfo.board[12] = "bbbbbbbbbbbbbbbbbbb";
					gameInfo.board[13] = "ewbwbwbwbwbwbwbwbwe";
					gameInfo.board[14] = "eebbbbbbeeebbbbbbee";
					gameInfo.board = gameInfo.board.map(function(cols) { return cols.split(""); });
				}
				function prepare() {
					ctx.clearRect ( 0 , 0 , ctx.canvas.width, ctx.canvas.height );
					// Main Window
					ctx.fillStyle = gameInfo.bgcolor;
					ctx.fillRect(0,0,800,600);
					
					// Board
					ctx.fillStyle = gameInfo.boardcolor;
					ctx.fillRect(20,20,gameInfo.boardwidth,gameInfo.boardheight);
					
					loadEntityBitmap();				
					loadBoardTiles();

					var x = 20;
					var y = 20;
					for (var r = 0; r < 15; r++) {
						for (var c = 0; c < 19; c++) {
							if (gameInfo.board[r][c] != "e") {
								drawItem(gameInfo.board[r][c], x, y);
							}
							x += 30;
						}
						// Reset x to left side.
						x = 20;
						y += 30;
					}
					clearBlock(0,3);
					clearBlock(2,2);
					clearBlock(3,0);
					clearBlock(3,18);
					clearBlock(4,0);
					clearBlock(14,5);
					drawPlayer("red",21,233, "r", 2);
					for (var n = 0; n < 8; n++) {
						drawBox(610,20 + (n * 57), 170, 50);
					}
					// Launch renderer.
					mainRender();
					
				}
				
				function drawBox(x,y,w,h) {
					//1 239 4 4 left-top
					//4 239 4 4 right-top
					//1 260 4 4 left-bottom
					//4 260 4 4 right-bottom
					ctx.beginPath();
					var offset = 3;
					ctx.moveTo(x, y + offset);
					ctx.lineTo(x + offset, y);
					ctx.lineTo(w + x - offset, y);
					ctx.lineTo(w + x, y + offset);
					ctx.lineTo(w + x, y + h - offset);
					ctx.lineTo(w + x - offset, y + h);
					ctx.lineTo(x + offset, y + h);
					ctx.lineTo(x, y + h - offset);
					ctx.lineTo(x, y + offset);
					ctx.closePath();
					ctx.fillStyle = '#496B8D';
					ctx.fill();
					ctx.strokeStyle = "#000000";
					ctx.stroke();
					
				}
				
				
				// ***** LISTENERS - KEYS
				
				
				$(document).keyup(function(e) {
				console.log("stopped");
					gameInfo.players["me"].isStopping = 1;
				});
				$(document).keydown(function(e) {
					// Up - Right - Down - Left
					if (e.keyCode == 38) {
						e.preventDefault();
						if (gameInfo.players["me"].dir != "u" || gameInfo.players["me"].isStopped) {
							gameInfo.players["me"].isStopped = 0;
							gameInfo.players["me"].dir = "u";
							gameInfo.players["me"].altDir = "0";
						}
					} else if (e.keyCode == 39) {
						e.preventDefault();
						gameInfo.players["me"].dir = "r";
						gameInfo.players["me"].altDir = "0";
					} else if (e.keyCode == 40) {
						e.preventDefault();
						if (gameInfo.players["me"].dir != "d" || gameInfo.players["me"].isStopped) {
							gameInfo.players["me"].isStopped = 0;
							gameInfo.players["me"].dir = "d";
							gameInfo.players["me"].altDir = "0";
						}
					} else if (e.keyCode == 37) {
						e.preventDefault();
						gameInfo.players["me"].dir = "l";
						gameInfo.players["me"].altDir = "0";
					} else if (e.keyCode == 32) {
						e.preventDefault();
						layBomb();
					}
					//38=up
					//39=right
					//40=down
					//37=left
				});
			//});			
		</script>
	</BODY>
</HTML>