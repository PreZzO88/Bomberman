<!doctype html>
<HTML>
	<HEAD>
		<TITLE>:: Bomberman</TITLE>
		<script src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
	</HEAD>
	<BODY style="background-color: #000000;">
		<div style="margin: 0px auto; text-align: center;">
			<canvas id="canvas" width="800" height="600" style="border-radius: 5px;"></canvas>
			<img id="bmcache" style="display: none;" src="imgs/bmcache.png" />
		</div>
		<script>
			//$(document).ready(function() {
				
				// Bomberman coded by David Preseault.
				// Note: Sprites and gameplay based on Jippii.fr Bomberman Game.
				
				var ctx = $("#canvas")[0].getContext("2d");
				var fpsctr = 0;
				var ts = new Date().getTime();
				var gameInfo = {
					bgcolor: "#4D7195",
					boardcolor: "#0075B9",
					board: [],
					boardx: 20,
					boardy: 20,
					boardw: 571,
					boardh: 451,
					assist: 4,
					me: "red",
					bmcache: $("#bmcache")[0],
					alternateAnimationSpeed: 200,
					players: { 
						red: { x: 0, y: 0, color: "red", dir: "u", altDir: 0, c: 0, isStopping: 0, isStopped: 1, speed: "normal", changingDir: 0 }
					},
					entityBitmap: {},
					speed: { normal: 0.5, fast: 0.75, fastest: 1 }
				};

				prepare();

				var timer = setInterval(
					function() {
						ctx.fillStyle = gameInfo.bgcolor;
						ctx.fillRect(10,1,40,11);
						ctx.font = "10pt verdana";
						ctx.fillStyle = "#FFFFFF";
						ctx.fillText(fpsctr + " FPS", 10, 10);
						fpsctr = 0;
					}, 1000);
				
				
				function mainRender() {
					fpsctr++;
					// players
					// items
					// active bombs
					// active explosions
					
					// Clear board and redraw everything except empty spaces.
					redrawBoard();
					
					var x, y, w, h, dir, isStopped, isStopping, speed, tlp, trp, rtp, rbp, blp, brp, ltp, lbp, assist;
					
					for (color in gameInfo.players) {
						var player = gameInfo.players[color];
						x = player.x;
						y = player.y;
						w = player.w;
						h = player.h;
						dir = player.dir;
						isStopped = player.isStopped;
						isStopping = player.isStopping;
						speed = gameInfo.speed[player.speed];
						tlp = player.tlp;
						trp = player.trp;
						rtp = player.rtp;
						rbp = player.rbp;
						blp = player.blp;
						brp = player.brp;
						ltp = player.ltp;
						lbp = player.lbp;
						assist = false;
						if (!isStopped) {
							switch (dir) {
								case "u":
									// UP
									var collisiontlp = isCollision(tlp);
									var collisiontrp = isCollision(trp);
									if (collisiontlp || collisiontrp) {
										drawPlayer(color, x, Math.floor(y), dir, 0);
										if (collisiontlp != collisiontrp) { 
											assist = checkForPlayerAssist(trp.x,dir,(collisiontlp ? trp.x : tlp.x));
										}
										if (assist != false) {
											movePlayer(color, assist+1, y-speed, speed, dir);
										} else {
											player.isStopping = 0;
											player.isStopped = 1;
										}
									} else {
										movePlayer(color, x, y, speed, dir);
									}
									break;
								case "r":
									// RIGHT
									var collisionrtp = isCollision(rtp);
									var collisionrbp = isCollision(rbp);
									if (collisionrtp || collisionrbp) {
										console.log(rtp);
										drawPlayer(color, x, y, dir, 0);
										if (collisionrtp != collisionrbp) { 
											console.log(assist);
											assist = checkForPlayerAssist(rbp.y,dir,(collisionrtp ? rbp.y : rtp.y));
											console.log(assist);
										}
										if (assist != false) {
											movePlayer(color, x+speed, assist+4, speed, dir);
										} else {
											player.isStopping = 0;
											player.isStopped = 1;
										}
									} else {
										movePlayer(color, x, y, speed, dir);
									}
									break;
								case "d":
									// DOWN
									var collisionblp = isCollision(blp);
									var collisionbrp = isCollision(brp);
									if (collisionblp || collisionbrp) {
										drawPlayer(color, x, y, dir, 0);
										player.isStopping = 0;
										player.isStopped = 1;
									} else {
										movePlayer(color, x, y, speed, dir);
									}
									break;
								case "l":
									// LEFT
									var collisionltp = isCollision(ltp);
									var collisionlbp = isCollision(lbp);
									if (collisionltp || collisionlbp) {
										drawPlayer(color, Math.floor(x), y, dir, 0);
										player.isStopping = 0;
										player.isStopped = 1;
									} else {
										movePlayer(color, x, y, speed, dir);
									}
									break;
							}
						} else {
							//console.log(color + " " + x + " " + y + " " + dir + " " + 0);
							drawPlayer(color, x, y, dir, 0);
						}
					}
					window.requestAnimationFrame(mainRender);
				}
				function checkForPlayerAssist(middlePoint,dir,successPoint) {
					var middle, successCol, p;
					var playerCenter = gameInfo.players[gameInfo.me].c;
					switch (dir) {
						case "u":
						case "d":
							middle = (Math.floor((middlePoint - gameInfo.boardx) / 30) * 30) + gameInfo.boardx;
							successCol = (Math.floor((successPoint - gameInfo.boardx) / 30) * 30) + gameInfo.boardx;
							p = "x";
							break;
						case "l":
						case "r":
							middle = (Math.floor((middlePoint - gameInfo.boardy) / 30) * 30) + gameInfo.boardy;
							successCol = (Math.floor((successPoint - gameInfo.boardy) / 30) * 30) + gameInfo.boardy;
							p = "y";
							break;
					}
					
					var diff = middle - playerCenter[p];
					if (Math.abs(diff) > gameInfo.assist) {
						// if diff is positive, means it was a left side trigger, check if empty space is to the left.
						if (diff > gameInfo.assist && successCol < middle) {
							// Left or Top Side triggered.
							console.log("left top");
							return successCol;
						}
						// if diff is negative, means it was a right side trigger, check if empty space is to the right.
						else if (diff < (-1 * gameInfo.assist) && successCol == middle) {
							// Right or Bottom side triggered.
							console.log("right bottom");
							return successCol;
						}
						else {
							return false;
						}
					} else {
						return false;
					}
					//console.log(col + " " + playerCenter.x);
				}
				function isCollision(pair) {
					var row = Math.floor((pair.y - gameInfo.boardy) / 30) + 1;
					var col = Math.floor((pair.x - gameInfo.boardx) / 30) + 1;
					//console.log(row + " " + col + " " + "collision: " + (gameInfo.board[row][col] != "e") + " " + gameInfo.players[gameInfo.me].dir);
					return (gameInfo.board[row][col] != "e");
				}
				function movePlayer(color, x, y, speed, dir) {
					var elapsed = new Date().getTime() - ts;
					var altDir = gameInfo.players[color].altDir;
					switch (dir) {
						case "u": y-=speed; break;
						case "d": y+=speed; break;
						case "l": x-=speed; break;
						case "r": x+=speed; break;
					}
					if (elapsed >= gameInfo.alternateAnimationSpeed) {
						ts = new Date().getTime();
						altDir++;
						if (altDir >= 3) { altDir = 1; }
					}
					if (gameInfo.players[color].isStopping) {
						gameInfo.players[color].altDir = 0;
						gameInfo.players[color].isStopping = 0;
						gameInfo.players[color].isStopped = 1;
					}
					gameInfo.players[color].altDir = altDir;
					drawPlayer(color, x, y, dir, altDir);
				}
				
				function layBomb() {
					var center = gameInfo.players[gameInfo.me].c;
					var row = Math.floor((center.y - 20) / 30) + 1;
					var col = Math.floor((center.x - 20) / 30) + 1;
					gameInfo.board[row][col] = "a";
				}
				
				function drawItem(item, x, y) {
					ctx.drawImage(bmcache, gameInfo.entityBitmap[item].x, gameInfo.entityBitmap[item].y, gameInfo.entityBitmap[item].w, gameInfo.entityBitmap[item].h, x, y, gameInfo.entityBitmap[item].w, gameInfo.entityBitmap[item].h);
				}
				function calculatePlayerBoundaries(x, y, w, h, speed) {
					var boundaries = {
						// Center
						c: { x: Math.floor((w / 2) + x), y: Math.floor((h / 2) + y) },
						
						// Top left pair
						tlp: { x: x, y: Math.floor(y-1-speed) },
						
						// Top right pair
						trp: { x: x+w-1 , y: Math.floor(y-1-speed) },
						
						// Right top pair
						rtp: { x: x+w-1+speed, y: y },
						
						// Right bottom pair
						rbp: { x: x+w-1+speed, y: y+h-1 },
						
						// Bottom right pair
						brp: { x: x+w-1, y: y+h-1+speed },
						
						// Bottom left pair
						blp: { x: x, y: y+h-1+speed },
						
						// Left bottom pair
						lbp: { x: Math.floor(x-1-speed), y: y+h-1 },
						
						// Left top pair
						ltp: { x: Math.floor(x-1-speed), y: y }
					}
					return boundaries;
				}
				function drawPlayer(color, x, y, direction, alt) {
					var w = gameInfo.entityBitmap[color][direction + alt].w;
					var h = gameInfo.entityBitmap[color][direction + alt].h;
					var player = gameInfo.players[color];
					var speed = Math.ceil(gameInfo.speed[player.speed]);
					var boundaries = calculatePlayerBoundaries(x, y, w, h, speed);

					if (player.changingDir) {
						if (player.dir == "u" || player.dir == "d") {
							// Get new x using old centre
							var testNewX = player["c"].x - Math.floor(w/2);
							boundaries = calculatePlayerBoundaries(testNewX, y, w, h, speed);
							var collisionLeft = (isCollision(boundaries.ltp) || isCollision(boundaries.lbp));
							var collisionRight = (isCollision(boundaries.rtp) || isCollision(boundaries.rbp));
							if (collisionLeft || collisionRight) { x = (Math.floor(((x - gameInfo.boardx) / 30)) * 30) + gameInfo.boardx + 1; }
							else { x = testNewX; }
							boundaries = calculatePlayerBoundaries(x, y, w, h, speed);
							player.changingDir = 0;
						} else {
							x = player["c"].x - Math.floor(w/2);
							boundaries = calculatePlayerBoundaries(x, y, w, h, speed);
							console.log(boundaries.rtp);
							player.changingDir = 0;
						}
					}

					player.x = x;
					player.y = y;
					player.w = w;
					player.h = h;
					for (bound in boundaries) {
						player[bound] = boundaries[bound];
					}
					ctx.drawImage(bmcache, gameInfo.entityBitmap[color][direction + alt].x, gameInfo.entityBitmap[color][direction + alt].y, w, h, x, y, w, h);
					/*ctx.beginPath();
					ctx.strokeStyle = "red";
					ctx.moveTo(x,y);
					ctx.lineTo(x+w-1,y);
					ctx.lineTo(x+w-1,y+h-1);
					ctx.lineTo(x,y+h-1);
					ctx.lineTo(x,y);
					ctx.closePath();
					ctx.stroke();
					
					ctx.beginPath();
					ctx.strokeStyle = "yellow";
					ctx.moveTo(player.tlp.x,player.tlp.y);
					ctx.lineTo(player.trp.x,player.trp.y);
					ctx.lineTo(player.rtp.x,player.rbp.y);
					ctx.lineTo(player.rbp.x,player.rbp.y);
					ctx.lineTo(player.brp.x,player.brp.y);
					ctx.lineTo(player.blp.x,player.blp.y);
					ctx.lineTo(player.lbp.x,player.lbp.y);
					ctx.lineTo(player.ltp.x,player.ltp.y);
					ctx.closePath();
					ctx.stroke();*/
				}
				
				// This function is called when user changes direction, once, to avoid sprite shifting position into another block.
				// For example, walking right until sprite hits a block, sprite changes direction to down, half of body is in wall.
				// Only called from up and down triggers since sprite is wider than he is thicker. w of [d|u] > w of [l|r]
				function correctPlayerPosition() {
					var me = gameInfo.players[gameInfo.me];
					var x = me.x;
					var y = me.y;
					var collisionRight = (isCollision(me.rtp) || isCollision(me.rbp));
					//console.log(collisionRight + " " + me.rtp.x);
					if (collisionRight) { x = (Math.floor(((x - gameInfo.boardx) / 30)) * 30) + 21; }
					return { x: x, y: y };
				}
								
				function loadBoardTiles() {
					gameInfo.board[0] = "ooooooooooooooooooooo";
					gameInfo.board[1] = "oeebbbbbbeeebbbbbbeeo";
					gameInfo.board[2] = "oewbwbwbwbwbwbwbwbweo";
					gameInfo.board[3] = "obbbbbbbbbbbbbbbbbbbo";
					gameInfo.board[4] = "obwbwbwbwbwbwbwbwbwbo";
					gameInfo.board[5] = "obbbbbbbbbbbbbbbbbbbo";
					gameInfo.board[6] = "obwbwbwbwbwbwbwbwbwbo";
					gameInfo.board[7] = "oebbbbbbbbbbbbbbbbbeo";
					gameInfo.board[8] = "oewbwbwbwbwbwbwbwbweo";
					gameInfo.board[9] = "oebbbbbbbbbbbbbbbbbeo";
					gameInfo.board[10] = "obwbwbwbwbwbwbwbwbwbo";
					gameInfo.board[11] = "obbbbbbbbbbbbbbbbbbbo";
					gameInfo.board[12] = "obwbwbwbwbwbwbwbwbwbo";
					gameInfo.board[13] = "obbbbbbbbbbbbbbbbbbbo";
					gameInfo.board[14] = "oewbwbwbwbwbwbwbwbweo";
					gameInfo.board[15] = "oeebbbbbbeeebbbbbbeeo";
					gameInfo.board[16] = "ooooooooooooooooooooo";
					gameInfo.board = gameInfo.board.map(function(cols) { return cols.split(""); });
				}
				function loadEntityBitmap() {
					gameInfo.entityBitmap["w"] = { x: 0, y: 30, w: 31, h: 31 };
					gameInfo.entityBitmap["b"] = { x: 0, y: 0, w: 31, h: 31 };
					gameInfo.entityBitmap["bomb"] = { x: 1, y: 145, w: 28, h: 30 };
					gameInfo.entityBitmap["armor"] = { x: 36, y: 203, w: 22, h: 27 };
					gameInfo.entityBitmap["speed"] = { x: 1, y: 62, w: 30, h: 22 };
					gameInfo.entityBitmap["exp"] = { x: 4, y: 85, w: 24, h: 26 };
					gameInfo.entityBitmap["a"] = { x: 0, y: 112, w: 30, h: 31 };
					
					var colors = [ "pink", "cyan", "red", "yellow", "blue", "lime", "gold", "green" ];
					var y = 0;
					for (color in colors) {
						gameInfo.entityBitmap[colors[color]] = {
							d0: { x: 33, y: y, w: 29, h: 23 }, d1: { x: 144, y: y, w: 29, h: 23 }, d2: { x: 255, y: y, w: 29, h: 23 },
							u0: { x: 87, y: y, w: 29, h: 23 }, u1: { x: 198, y: y, w: 29, h: 22 }, u2: { x: 309, y: y, w: 29, h: 22 },
							r0: { x: 120, y: y, w: 20, h: 23 }, r1: { x: 231, y: y, w: 20, h: 23 }, r2: { x: 342, y: y, w: 20, h: 23 },
							l0: { x: 65, y: y, w: 20, h: 23 }, l1: { x: 176, y: y, w: 20, h: 23}, l2: { x: 287, y: y, w: 20, h: 23 }
						};
						y+= 25;
					}
				}
				
				function redrawBoard() {
					// Board Fill
					ctx.fillStyle = gameInfo.boardcolor;
					ctx.fillRect(gameInfo.boardx,gameInfo.boardy,gameInfo.boardw,gameInfo.boardh);
					
					// Put all items on board except empty.
					// Starting at row 1 and col 1 and ending 1 short of each due to outside border being "outside" area.
					var x = gameInfo.boardx;
					var y = gameInfo.boardy;
					var item;
					for (var r = 1; r < gameInfo.board.length-1; r++ ) {
						for (var c = 1; c < gameInfo.board[r].length-1; c++) {
							item = gameInfo.board[r][c];
							if (item != "e") {
								drawItem(item, x, y);
							}
							x += 30;
						}
						x = gameInfo.boardx;
						y += 30;
					}
				}
				function prepare() {
					ctx.clearRect ( 0 , 0 , ctx.canvas.width, ctx.canvas.height );
					// Main Window
					ctx.fillStyle = gameInfo.bgcolor;
					ctx.fillRect(0,0,800,600);
					
					loadEntityBitmap();				
					loadBoardTiles();
					
					// Board
					redrawBoard();
					
					drawPlayer("red",21,233, "d", 0);
					for (var n = 0; n < 8; n++) {
						drawBox(610,20 + (n * 57), 170, 50);
					}
					// Launch renderer.
					mainRender();
					
				}
				
				function drawBox(x,y,w,h) {
					//1 239 4 4 left-top
					//4 239 4 4 right-top
					//1 260 4 4 left-bottom
					//4 260 4 4 right-bottom
					ctx.beginPath();
					var offset = 3;
					ctx.moveTo(x, y + offset);
					ctx.lineTo(x + offset, y);
					ctx.lineTo(w + x - offset, y);
					ctx.lineTo(w + x, y + offset);
					ctx.lineTo(w + x, y + h - offset);
					ctx.lineTo(w + x - offset, y + h);
					ctx.lineTo(x + offset, y + h);
					ctx.lineTo(x, y + h - offset);
					ctx.lineTo(x, y + offset);
					ctx.closePath();
					ctx.fillStyle = '#496B8D';
					ctx.fill();
					ctx.strokeStyle = "#000000";
					ctx.stroke();
					
				}
				
				
				// ***** LISTENERS - KEYS
				
				
				$(document).keyup(function(e) {
					//console.log("stopped");
					if (e.keyCode != 32) {
						var player = gameInfo.players[gameInfo.me];
						player.isStopping = 1;
					}
				});
				$(document).keydown(function(e) {
					// Up - Right - Down - Left
					var player = gameInfo.players[gameInfo.me];
					if (e.keyCode == 38) {
						e.preventDefault();
						if (player.dir != "u" || player.isStopped) {
							player.changingDir = (player.dir != "u" ? 1 : 0);
							player.isStopped = 0;
							player.dir = "u";
							player.altDir = 0;
						}
					} else if (e.keyCode == 39) {
						e.preventDefault();
						if (player.dir != "r" || player.isStopped) {
							player.changingDir = (player.dir != "r" ? 1 : 0);
							player.isStopped = 0;
							player.dir = "r";
							player.altDir = 0;
						}
					} else if (e.keyCode == 40) {
						e.preventDefault();
						if (player.dir != "d" || player.isStopped) {
							player.changingDir = (player.dir != "d" ? 1 : 0);
							player.isStopped = 0;
							player.dir = "d";
							player.altDir = 0;
						}
					} else if (e.keyCode == 37) {
						e.preventDefault();
						if (player.dir != "l" || player.isStopped) {
							player.changingDir = (player.dir != "l" ? 1 : 0);
							player.isStopped = 0;
							player.dir = "l";
							player.altDir = 0;
						}
					} else if (e.keyCode == 32) {
						e.preventDefault();
						layBomb();
					}
					//38=up
					//39=right
					//40=down
					//37=left
				});
			//});			
		</script>
	</BODY>
</HTML>